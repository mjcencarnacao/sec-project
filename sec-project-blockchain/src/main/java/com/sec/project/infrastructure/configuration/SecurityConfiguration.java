package com.sec.project.infrastructure.configuration;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import java.security.*;
import java.security.spec.X509EncodedKeySpec;
import java.util.Base64;

import static com.sec.project.infrastructure.repositories.KeyExchangeServiceImplementation.publicKeyPeerHashMap;
import static com.sec.project.utils.Constants.*;

/**
 * Spring Boot component that will handle the Security Configurations for our application's infrastructure.
 * Asymmetric and symmetric encryption logic should be handled here and injected in other components.
 */
@Component
public class SecurityConfiguration {

    /**
     * Asymmetric <Public,Private> key pair for the client service.
     */
    private final KeyPair keyPair;

    /**
     * Current Symmetric Communication Key
     */
    private SecretKey symmetricKey = null;

    /**
     * Cipher objects for encryption and decryption
     */
    private final Cipher symmetricCipher = Cipher.getInstance(SYMMETRIC_TRANSFORMATION_ALGORITHM);
    private final Cipher asymmetricCipher = Cipher.getInstance(ASYMMETRIC_TRANSFORMATION_ALGORITHM);

    /**
     * MessageDigest object to generate the hashes of an array of bytes representing the data.
     */
    private final MessageDigest messageDigest = MessageDigest.getInstance(DIGEST_ALGORITHM);


    /**
     * Initializes the key pair defined above using the RSA algorithm, which is defined in the Constants.java file.
     *
     * @throws NoSuchAlgorithmException In case an invalid asymmetric algorithm is added to the ALGORITHM constant.
     * @see com.sec.project.utils.Constants
     */
    @Autowired
    public SecurityConfiguration() throws Exception {
        KeyPairGenerator generator = KeyPairGenerator.getInstance(ASYMMETRIC_ALGORITHM);
        SecureRandom random = SecureRandom.getInstance("SHA1PRNG");
        generator.initialize(ASYMMETRIC_KEY_SIZE, random);
        this.keyPair = generator.generateKeyPair();
    }

    /**
     * Conversion of a byte array to a public key object.
     *
     * @param bytes containing the key.
     * @return public key from the byte array.
     */
    public PublicKey bytesArrayToPublicKey(byte[] bytes) throws Exception {
        return KeyFactory.getInstance(ASYMMETRIC_ALGORITHM).generatePublic(new X509EncodedKeySpec(bytes));
    }

    /**
     * Returns the public key for the running node instance.
     *
     * @return public key from the key pair.
     */
    public PublicKey getPublicKey() {
        return keyPair.getPublic();
    }

    /**
     * Returns the private key for the running node instance.
     *
     * @return private key from the key pair.
     */
    public PrivateKey getPrivateKey() {
        return keyPair.getPrivate();
    }

    /**
     * Returns the Secret key for the running IBFT instance.
     *
     * @return secret key agreed upon peers.
     */
    public SecretKey getSymmetricKey() {
        return symmetricKey;
    }

    /**
     * Setter for the secret key.
     *
     * @param symmetricKey generated by the round leader.
     */
    public void setSymmetricKey(SecretKey symmetricKey) {
        this.symmetricKey = symmetricKey;
    }

    /**
     * Asymmetric encoding support using RSA.
     *
     * @param input bytes to encrypt.
     * @return encrypted bytes.
     */
    public byte[] asymmetricEncoding(byte[] input) {
        try {
            asymmetricCipher.init(Cipher.ENCRYPT_MODE, getPrivateKey());
            return asymmetricCipher.doFinal(input);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Asymmetric decoding support using RSA.
     *
     * @param encoded bytes to decrypt.
     * @param port    to retrieve the public key from the peer.
     * @return decrypted bytes.
     */
    public byte[] asymmetricDecoding(byte[] encoded, int port) {
        try {
            asymmetricCipher.init(Cipher.DECRYPT_MODE, publicKeyPeerHashMap.get(port));
            return asymmetricCipher.doFinal(encoded);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Symmetric encoding support using AES.
     *
     * @param input bytes to encrypt.
     * @return encrypted bytes.
     */
    public byte[] symmetricEncoding(byte[] input) {
        try {
            symmetricCipher.init(Cipher.ENCRYPT_MODE, symmetricKey);
            return symmetricCipher.doFinal(input);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Symmetric encoding support using AES.
     *
     * @param bytes bytes to decrypt.
     * @return decrypted bytes.
     */
    public byte[] symmetricDecoding(byte[] bytes) {
        try {
            symmetricCipher.init(Cipher.DECRYPT_MODE, symmetricKey);
            return symmetricCipher.doFinal(bytes);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates a symmetric key using AES. Used by the Leader node.
     *
     * @return secret key generated.
     */
    public SecretKey getEncodedSymmetricKey() {
        try {
            KeyGenerator keygen = KeyGenerator.getInstance(SYMMETRIC_ALGORITHM);
            keygen.init(SYMMETRIC_KEY_SIZE);
            return keygen.generateKey();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates a hash string for a given array of bytes.
     *
     * @param data object converted to a byte array.
     * @return string representing the SHA-256 hash.
     */
    public String generateMessageDigest(byte[] data) {
        messageDigest.update(data);
        return Base64.getEncoder().encodeToString(messageDigest.digest());
    }

}
